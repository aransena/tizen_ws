

/*******************************************************************************
* This file was generated by UI Builder.
* This file will be auto-generated each and everytime you save your project.
* Do not hand edit this file.
********************************************************************************/

#include <Elementary.h>
#include <app.h>
#include "uib_common.h"
#include "uib_views.h"
#include "view_data.h"

#define CIRCLE_360x360_SCALE 1.4

static uib_view_data* view_data = NULL;

uib_view_data* get_uib_view_data() {
	if (view_data == NULL) {
		view_data = calloc(1, sizeof(uib_view_data));
	}
	return view_data;
}

//This code will be updated on every View addition and deletion
uib_view_context* get_view(Evas_Object *naviframe, char *view_name)
{
	uib_view_data* view_data = get_uib_view_data();
	
	if(!strcmp(view_name,"view1")) {
		view_data->view1 = uib_view1_view_create(naviframe, NULL);
		return view_data->view1;
	} else if(!strcmp(view_name,"view2")) {
		view_data->view2 = uib_view2_view_create(naviframe, NULL);
		return view_data->view2;
	}
	return NULL;
}


Elm_Object_Item* change_page(Evas_Object *naviframe, const char *title_label, Evas_Object *prev_btn, Evas_Object *next_btn, char *view_name, const char *item_style)
{
	uib_view_context* view = get_view(naviframe, view_name);
	if(view == NULL)
		return NULL;

	return elm_naviframe_item_push(naviframe, title_label, prev_btn, next_btn, view->root_container, item_style);
}

void uib_view_create_callback(void* vc, Evas* e, Evas_Object* obj, void* event_info) {
	evas_object_smart_callback_call(obj, KEY_VIEW_CREATE, event_info);
}

void uib_view_destroy_callback(void* vc, Evas* e, Evas_Object* obj, void* event_info) {
	evas_object_smart_callback_call(obj, KEY_VIEW_DESTROY, event_info);
	if (vc) {
		free(vc);
	}
}

void base_scale_set(){
	elm_app_base_scale_set(CIRCLE_360x360_SCALE);
}

uib_view_context* startup_view_create(void *data)
{
	app_data* ad = (app_data*)data;
	uib_view_context* vc = uib_view1_view_create(ad->win, NULL);
	if (vc) {
		elm_object_part_content_set(ad->conformant, "elm.swallow.content", vc->root_container);
	}

	return vc;
}

void win_create(void *data)
{
	app_data* ad = (app_data*)data;
	
	ad->win = elm_win_add(NULL, "main", ELM_WIN_BASIC);
	elm_win_conformant_set(ad->win, EINA_TRUE);
	evas_object_show(ad->win);

	elm_win_indicator_mode_set(ad->win, ELM_WIN_INDICATOR_SHOW);
	ad->conformant = elm_conformant_add(ad->win);
	evas_object_size_hint_weight_set(ad->conformant, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
	elm_win_resize_object_add(ad->win, ad->conformant);
	evas_object_show(ad->conformant);
	
	ad->circle_surface = eext_circle_surface_conformant_add(ad->conformant);

	ad->bg = elm_bg_add(ad->conformant);
	evas_object_size_hint_weight_set(ad->bg, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
	evas_object_show(ad->bg);

	elm_object_part_content_set(ad->conformant, "elm.swallow.bg", ad->bg);
	evas_object_data_set(ad->win, "root", ad);
}

void win_destroy(void *data)
{
	app_data* ad = (app_data*)data;
	if (ad) {
		evas_object_del(ad->win);
		free(ad);
	}
}

/***********************************************************************************************
 *
 * item class callbacks
 *
 ***********************************************************************************************/
static Evas_Object* create_image(Evas_Object* parent, const char* path) {
	Evas_Object *icon = elm_icon_add(parent);
	char buf[PATH_MAX];
	snprintf(buf, sizeof(buf), "%s%s", app_get_resource_path(), path);
	elm_image_file_set(icon, buf, NULL);
	evas_object_size_hint_aspect_set(icon, EVAS_ASPECT_CONTROL_VERTICAL, 1,	1);
	evas_object_show(icon);
	return icon;
}

char* uib_genlist_label_get(void *data, Evas_Object *obj, const char *part) {
	uib_genlist_item *item = (uib_genlist_item*)data;
	if(!strcmp(part, "elm.text")) {
		if (item->label) {
			return strdup(item->label);
		}
	}
	else if (!strcmp(part, "elm.text.sub")) {
		if (item->sub_label) {
			return strdup(item->sub_label);
		}
	}
	return NULL;
}

Evas_Object* uib_genlist_icon_get(void *data , Evas_Object *obj, const char *part) {
	uib_genlist_item *item = (uib_genlist_item*) data;
	if (!strcmp(part, "elm.swallow.icon")) {
		if(item->icon_standard){
			Evas_Object *ic = elm_icon_add(obj);
			elm_icon_standard_set(ic, item->icon_standard);
			evas_object_size_hint_aspect_set(ic, EVAS_ASPECT_CONTROL_VERTICAL, 1, 1);
			return ic;
		} else if(item->icon_path){
			return create_image(obj, item->icon_path);
		}
	}
		
		
	if (!strcmp(part, "elm.swallow.end")) {
		if (item->end_icon_standard) {
			Evas_Object *ic = elm_icon_add(obj);
			elm_icon_standard_set(ic, item->end_icon_standard);
			evas_object_size_hint_aspect_set(ic, EVAS_ASPECT_CONTROL_VERTICAL, 1, 1);
			return ic;
		} else if (item->end_icon_path) {
			return create_image(obj, item->end_icon_path);
		}
	}
	return NULL;
}

Eina_Bool uib_genlist_state_get(void *data , Evas_Object *obj , const char *part) {
	return EINA_FALSE;
}

void uib_genlist_del(void *data , Evas_Object *obj) {
	uib_genlist_item *item = (uib_genlist_item*)data;
	if (item) {
		if (item->label) free(item->label);
		if (item->sub_label) free(item->sub_label);
		if (item->icon_path) free(item->icon_path);
		if (item->icon_standard) free(item->icon_standard);
		if (item->end_icon_path) free(item->end_icon_path);
		if (item->end_icon_standard) free(item->end_icon_standard);
		free(item);
	}
}

char* uib_gengrid_label_get(void *data, Evas_Object *obj, const char *part) {
	uib_gengrid_item *item = (uib_gengrid_item*)data;
	if (item->label) {
		return strdup(item->label);
	} else {
		return NULL;
	}
}

Evas_Object* uib_gengrid_icon_get(void *data, Evas_Object *obj, const char *part) {
	uib_gengrid_item *item = (uib_gengrid_item*) data;
	if (!strcmp(part, "elm.swallow.icon") && item->icon_path) {
		return create_image(obj, item->icon_path);
	} else {
		return NULL;
	}
}

Eina_Bool uib_gengrid_state_get(void *data, Evas_Object *obj, const char *part) {
	return EINA_FALSE;
}

void uib_gengrid_del(void *data, Evas_Object *obj) {
	uib_gengrid_item *item = (uib_gengrid_item*)data;
	if (item) {
		if (item->label) free(item->label);
		if (item->icon_path) free(item->icon_path);
		free(item);
	}
}

Elm_Genlist_Item_Class* _itc = NULL;
Elm_Genlist_Item_Class* _itt = NULL;
Elm_Genlist_Item_Class* _itp = NULL;
Elm_Genlist_Item_Class* _itg = NULL;

Elm_Gengrid_Item_Class* _gic = NULL;
Elm_Gengrid_Item_Class* _gig = NULL;
Elm_Gengrid_Item_Class* _gia = NULL;
Elm_Gengrid_Item_Class* _gib = NULL;

void initialize_circle_genlist_class(const char* style) {
	if (!_itc) {
		_itc = elm_genlist_item_class_new();
		_itc->item_style = "default";
		_itc->func.text_get = uib_genlist_label_get;
		_itc->func.content_get = uib_genlist_icon_get;
		_itc->func.state_get = uib_genlist_state_get;
		_itc->func.del = uib_genlist_del;
	}

	if (!_itt) {
		_itt = elm_genlist_item_class_new();
		_itt->item_style = "title";
		_itt->func.text_get = uib_genlist_label_get;
		_itt->func.content_get = uib_genlist_icon_get;
		_itt->func.state_get = uib_genlist_state_get;
		_itt->func.del = uib_genlist_del;
	}

	if (!_itp) {
		_itp = elm_genlist_item_class_new();
		_itp->item_style = "padding";
		_itp->func.text_get = uib_genlist_label_get;
		_itp->func.content_get = uib_genlist_icon_get;
		_itp->func.state_get = uib_genlist_state_get;
		_itp->func.del = uib_genlist_del;
	}

	if (!_itg) {
		_itg = elm_genlist_item_class_new();
		_itg->item_style = "groupindex";
		_itg->func.text_get = uib_genlist_label_get;
		_itg->func.content_get = uib_genlist_icon_get;
		_itg->func.state_get = uib_genlist_state_get;
		_itg->func.del = uib_genlist_del;
	}
}

void initialize_gengrid_class(const char* style) {
	if (!_gic) {
		_gic = elm_gengrid_item_class_new();
		_gic->item_style = style;
		_gic->func.text_get = uib_gengrid_label_get;
		_gic->func.content_get = uib_gengrid_icon_get;
		_gic->func.state_get = uib_gengrid_state_get;
		_gic->func.del = uib_gengrid_del;
	}

	if (!_gig) {
		_gig = elm_gengrid_item_class_new();
		_gig->item_style = "group_index";
		_gig->func.text_get = uib_gengrid_label_get;
		_gig->func.content_get = uib_gengrid_icon_get;
		_gig->func.state_get = uib_gengrid_state_get;
		_gig->func.del = uib_gengrid_del;
	}

	if (!_gia) {
		_gia = elm_gengrid_item_class_new();
		_gia->item_style = "album-preview";
		_gia->func.text_get = uib_gengrid_label_get;
		_gia->func.content_get = uib_gengrid_icon_get;
		_gia->func.state_get = uib_gengrid_state_get;
		_gia->func.del = uib_gengrid_del;
	}

	if (!_gib) {
		_gib = elm_gengrid_item_class_new();
		_gib->item_style = "block";
		_gib->func.text_get = uib_gengrid_label_get;
		_gib->func.content_get = uib_gengrid_icon_get;
		_gib->func.state_get = uib_gengrid_state_get;
		_gib->func.del = uib_gengrid_del;
	}
}

Elm_Object_Item* create_multibuttonentry_item(Evas_Object* multibuttonentry, const char* label, Evas_Smart_Cb func, void* data) {
	Elm_Object_Item* item = elm_multibuttonentry_item_append(multibuttonentry, label, func, data); 
	return item;
}

Elm_Object_Item* create_gengrid_item(Evas_Object* gengrid, const char* style, const char* label, const char* path, Evas_Smart_Cb func, void* data) {
	uib_gengrid_item* item = malloc(sizeof(uib_gengrid_item));
	memset(item, 0x0, sizeof(uib_gengrid_item));	
	item->label = strdup(label);	
	item->icon_path = strdup(path);

	if(!strcmp(style, "album-preview")) {
		return elm_gengrid_item_append(gengrid, _gia, item, func, data);
	} else if(!strcmp(style, "block")) {
		return elm_gengrid_item_append(gengrid, _gib, item, func, data);
	} else if(!strcmp(style, "group_index")) {
		return elm_gengrid_item_append(gengrid, _gig, item, func, data);
	}
	return elm_gengrid_item_append(gengrid, _gic, item, func, data);
}

Elm_Object_Item* create_circle_genlist_item(Evas_Object* genlist, const char* label, const char* sub_label, const char* icon_path, const char* icon_standard, const char* end_icon_path, const char* end_icon_standard, Elm_Object_Item* parent, const char* style, Evas_Smart_Cb func, void* data){
	uib_genlist_item* item = malloc(sizeof(uib_genlist_item));
	memset(item, 0x0, sizeof(uib_genlist_item));

	item->label = strdup(label);
	item->sub_label = strdup(sub_label);
	if(strlen(icon_standard) != 0){
		item->icon_standard = strdup(icon_standard);
	} else if(strlen(icon_path) != 0){
		item->icon_path = strdup(icon_path);
	}
	
	if(strlen(end_icon_standard) != 0){
		item->end_icon_standard = strdup(end_icon_standard);
	} else if(strlen(end_icon_path) != 0){
		item->end_icon_path = strdup(end_icon_path);
	}

	if(!strcmp("groupindex", style)){
		return elm_genlist_item_append(genlist, _itg, item, parent, ELM_GENLIST_ITEM_GROUP, func, data);
	}else if(!strcmp("title", style)){
		return elm_genlist_item_append(genlist, _itt, item, parent, ELM_GENLIST_ITEM_NONE, func, data);
	}else if(!strcmp("padding", style)){
		return elm_genlist_item_append(genlist, _itp, item, parent, ELM_GENLIST_ITEM_NONE, func, data);
	}else {
		return elm_genlist_item_append(genlist, _itc, item, parent, ELM_GENLIST_ITEM_NONE, func, data);
	}
}

